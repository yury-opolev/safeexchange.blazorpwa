@using SafeExchange.Client.Web.Components.Model
@using Microsoft.AspNetCore.Components.WebAssembly.Authentication
@using System.Text.RegularExpressions;

@implements IDisposable

@inject NavigationManager NavManager
@inject ApiClient apiClient
@inject StateContainer StateContainer

<div class="modal fade" id="deletionDialog" tabindex="-1" role="dialog" aria-labelledby="modalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="modalLabel">Delete secret</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                Are you sure you want to delete the secret?
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" data-bs-dismiss="modal" @onclick="DeleteSecretAsync">Yes</button>
            </div>
        </div>
    </div>
</div>

@if (this.IsInProgress)
{
    <p>
        <div class="progress">
            <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" aria-valuenow="75" aria-valuemin="0" aria-valuemax="100" style="width: 75%"></div>
        </div>
    </p>
}

@if (this.Notification != null)
{
    <div class="alert alert-dismissible @(this.Notification.GetAlertClass() ?? "alert-primary")" role="alert">
        <p>
            <strong>@(this.Notification.Status ?? string.Empty)</strong>&nbsp; @(this.Notification.Message ?? string.Empty)
        </p>
        @if (!string.IsNullOrEmpty(this.Notification.ButtonText))
        {
            <hr>
            <p>
                <button class="btn btn-warning" type="button" disabled="@IsInProgress" @onclick="() => this.NavManager.NavigateTo(this.Notification.ButtonUri)">
                    <span>@this.Notification.ButtonText</span>
                </button>
            </p>
        }
        <button type="button" class="btn-close" @onclick="DismissNotification" aria-label="Close"></button>
    </div>

}

@if (this.inputModel != null)
{
    <EditForm EditContext="@editContext" OnValidSubmit="@TryUpdateSecretAsync">
        <DataAnnotationsValidator />

        <p>
            <InputTextArea class="form-control col" rows="18" disabled="@IsInProgress" @bind-Value="inputModel.Data.Value" placeholder="Content" />
            <ValidationMessage For="@(() => inputModel.Data.Value)" />
        </p>

        <p>
            <div class="form-check form-switch">
                <InputCheckbox class="form-check-input" type="checkbox" id="destroyAfterReadSwitch" disabled="@IsInProgress" @bind-Value="inputModel.Data.DestroySettings.DestroyAfterRead" />
                <label class="form-check-label" for="destroyAfterReadSwitch">Destroy After Read</label>
            </div>
        </p>
        <p>
            <div class="form-check form-switch">
                <InputCheckbox class="form-check-input" type="checkbox" id="scheduleDestroySwitch" disabled="@IsInProgress" @bind-Value="inputModel.Data.DestroySettings.ScheduleDestroy" />
                <label class="form-check-label" for="scheduleDestroySwitch">Schedule Destroy</label>
            </div>
        </p>
        <p>
            <div class="form-group form-row">
                <label for="destroy-datetime-input" class="col-2 col-form-label">Destroy At:</label>
                <div class="col-10">
                    <InputDateTime id="destroy-datetime-input" class="form-control" type="datetime-local" disabled="@IsInProgress" @bind-Value="inputModel.Data.DestroySettings.DestroyAt" DisplayName="DestroyAt" />
                </div>
            </div>
        </p>

        <h5>Access list:</h5>

        @for (int i = 0; i < inputModel.AccessList.Count; i++)
        {
            var tempIndex = i;
            <p>
                <div class="row">
                    <div class="col">
                        <InputText class="@(this.IsDeleted(tempIndex)? "form-control text-removed" : "form-control bg-light")" disabled="@IsInProgress" @bind-Value="inputModel.AccessList[tempIndex].Subject" placeholder="Username" readonly="@(tempIndex < this.FixedAccessItemCount)" />
                        <ValidationMessage For="@(() => inputModel.AccessList[tempIndex].Subject)" />
                    </div>
                    <div class="col">
                        @if (tempIndex < this.FixedAccessItemCount)
                        {
                            <InputText class="@(this.IsDeleted(tempIndex)? "form-control text-removed" : "form-control bg-light")" disabled="@IsInProgress" @bind-Value="inputModel.AccessList[tempIndex].Permission" readonly />
                        }
                        else
                        {
                            <InputSelect class="form-control bg-light" disabled="@IsInProgress" @bind-Value="inputModel.AccessList[tempIndex].Permission">
                                <option>Read</option>
                                <option>Read,Write</option>
                                <option>Read,Write,GrantAccess</option>
                                <option>Read,Write,GrantAccess,RevokeAccess</option>
                            </InputSelect>
                        }
                    </div>
                    <div class="col-3">
                        @if (this.IsDeleted(tempIndex))
                        {
                            <button class="btn btn-outline-secondary" type="button" disabled="@IsInProgress" @onclick="@(e => this.RemovePermissionItem(tempIndex))"><span class="oi oi-action-undo"></span></button>
                        }
                        else
                        {
                            <button class="btn btn-outline-danger" type="button" disabled="@IsInProgress" @onclick="@(e => this.RemovePermissionItem(tempIndex))"><span class="oi oi-x"></span></button>
                        }
                    </div>
                </div>
            </p>
        }
        <p>
            <div class="row">
                <div class="col">
                    <button class="btn btn-outline-primary" type="button" disabled="@IsInProgress" @onclick="AddPermissionItem"><span class="oi oi-plus"></span>&nbsp; Add user</button>
                </div>
            </div>
        </p>

        <p>
            <div class="d-flex justify-content-center">
                <button type="submit" class="btn btn-primary mx-2" disabled="@(IsInProgress || !this.isValidData)">Update</button>
                <button type="button" class="btn btn-danger mx-2" data-bs-toggle="modal" data-bs-target="#deletionDialog" disabled="@IsInProgress">
                    Delete
                </button>
            </div>
        </p>
    </EditForm>
}

@code {

    [Parameter]
    public string ObjectName { get; set; }

    private NotificationData Notification;

    private bool IsInProgress;

    private EditContext editContext;

    private bool isValidData = true;

    private SecretInput inputModel;

    private int FixedAccessItemCount = 0;

    private List<int> DeletedAccessItems = new List<int>();

    public void Dispose()
    {
        editContext.OnFieldChanged -= this.HandleFieldChanged;
    }

    protected override async Task OnInitializedAsync()
    {
        this.StateContainer.TakeNotification();

        this.ObjectName = this.ObjectName ?? string.Empty;
        this.StateContainer.SetCurrentPageHeader($"Edit '{this.ObjectName}'");

        await this.FetchSecretAsync(this.ObjectName);

        this.editContext = new EditContext(this.inputModel);
        this.editContext.OnFieldChanged += this.HandleFieldChanged;
    }

    private void HandleFieldChanged(object sender, FieldChangedEventArgs e)
    {
        isValidData = this.IsCurrentDataValid();
    }

    private bool IsCurrentDataValid()
    {
        // TODO: remove after nested objects validation is available
        if (string.IsNullOrEmpty(this.inputModel?.Name))
        {
            return false;
        }

        if (this.inputModel.Name.Length > 63)
        {
            return false;
        }

        var nameRegex = new Regex(@"^[0-9a-zA-Z-]+$");
        if (!nameRegex.IsMatch(this.inputModel.Name))
        {
            return false;
        }

        if (string.IsNullOrEmpty(this.inputModel.Data?.Value))
        {
            return false;
        }

        if ((this.inputModel.Data?.Value?.Length ?? 0) > 25000)
        {
            return false;
        }

        var regex = new Regex(@"^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$");
        var accessList = this.inputModel.AccessList ?? new List<AccessDataInput>();
        foreach (var accessItem in accessList)
        {
            if (string.IsNullOrEmpty(accessItem.Subject))
            {
                continue;
            }

            if (accessItem.Subject.Length > 63 || !regex.IsMatch(accessItem.Subject))
            {
                return false;
            }
        }

        return true;
    }

    private void AddPermissionItem()
    {
        this.inputModel.AccessList.Add(new AccessDataInput() { Permission = "Read" });
    }

    private void RemovePermissionItem(int index)
    {
        if (index >= this.FixedAccessItemCount)
        {
            this.inputModel.AccessList.RemoveAt(index);
            return;
        }

        if (this.DeletedAccessItems.Contains(index))
        {
            this.DeletedAccessItems.Remove(index);
        }
        else
        {
            this.DeletedAccessItems.Add(index);
        }
    }

    private bool IsDeleted(int index)
    {
        return this.DeletedAccessItems.Contains(index);
    }

    private async Task FetchSecretAsync(string objectName)
    {
        this.IsInProgress = true;
        try
        {
            var accessData = await apiClient.ReadAccessAsync(objectName);
            if (!"ok".Equals(accessData.Status))
            {
                this.Notification = new NotificationData()
                {
                    Type = NotificationType.Warning,
                    Status = accessData.Status,
                    Message = accessData.Error,
                    ButtonText = "unauthorized".Equals(accessData.Status) ? "Request Access" : string.Empty,
                    ButtonUri = this.CreateAccessRequestUri("Read,Write")
                };
                return;
            }

            var secretData = await apiClient.GetSecretDataAsync(objectName);
            if (!"ok".Equals(secretData.Status))
            {
                this.Notification = new NotificationData()
                {
                    Type = NotificationType.Warning,
                    Status = secretData.Status,
                    Message = secretData.Error,
                    ButtonText = "unauthorized".Equals(secretData.Status) ? "Request Access" : string.Empty,
                    ButtonUri = this.CreateAccessRequestUri("Read,Write")
                };
                return;
            }

            this.Notification = null;

            this.inputModel = new SecretInput()
            {
                Name = this.ObjectName,
                Data = new SecretDataInput()
                {
                    Value = secretData.Result.Secret,
                    ContentType = secretData.Result.ContentType,
                    DestroySettings = secretData.Result.DestroySettings
                },
                AccessList = new List<AccessDataInput>()
            };

            foreach (var accessItem in accessData.AccessList)
            {
                this.inputModel.AccessList.Add(new AccessDataInput() { Subject = accessItem.UserName, Permission = AccessDataInput.CreatePermissionsString(accessItem) });
            }

            this.FixedAccessItemCount = this.inputModel.AccessList.Count;
        }
        catch (AccessTokenNotAvailableException exception)
        {
            exception.Redirect();
        }
        finally
        {
            this.IsInProgress = false;
        }
    }

    private async Task TryUpdateSecretAsync()
    {
        if (this.inputModel == null || !this.IsCurrentDataValid())
        {
            return;
        }

        this.IsInProgress = true;

        var inputData = new SecretDataInput()
        {
            Value = this.inputModel.Data.Value,
            ContentType = this.inputModel.Data.ContentType,
            DestroySettings = this.inputModel.Data.DestroySettings
        };

        try
        {
            var secretData = await apiClient.UpdateSecretDataAsync(this.inputModel.Name, inputData);
            if (!"ok".Equals(secretData.Status))
            {
                this.Notification = new NotificationData()
                {
                    Type = NotificationType.Warning,
                    Status = secretData.Status,
                    Message = secretData.Error,
                    ButtonText = "unauthorized".Equals(secretData.Status) ? "Request Access" : string.Empty,
                    ButtonUri = this.CreateAccessRequestUri("Read,Write")
                };
                return;
            }

            var missingAccess = string.Empty;
            foreach (var deletedIndex in this.DeletedAccessItems)
            {
                var accessItem = this.inputModel.AccessList[deletedIndex];
                var accessReply = await apiClient.RevokeAccessAsync(this.inputModel.Name, accessItem);
                if (!"ok".Equals(accessReply.Status))
                {
                    missingAccess = "Read,Write,GrantAccess,RevokeAccess";
                }
            }

            for (int index = 0; index < this.inputModel.AccessList.Count; index++)
            {
                if (index < this.FixedAccessItemCount)
                {
                    continue;
                }

                var accessItem = this.inputModel.AccessList[index];
                var accessReply = await apiClient.GrantAccessAsync(this.inputModel.Name, accessItem);
                if (!"ok".Equals(accessReply.Status))
                {
                    missingAccess = string.IsNullOrEmpty(missingAccess) ? "Read,Write,GrantAccess" : missingAccess;
                }
            }

            var needToRequestAccess = !string.IsNullOrEmpty(missingAccess);
            var notification = new NotificationData()
            {
                Type = needToRequestAccess ? NotificationType.Warning : NotificationType.Success,
                Status = needToRequestAccess ? "Success/Warning" : "Success",
                Message = needToRequestAccess ? $"Secret '{this.inputModel.Name}' updated successfully, but access was not updated." : $"Secret '{this.inputModel.Name}' updated successfully",
                CopyableUri = this.GetViewUri(this.inputModel.Name),
                ButtonText = needToRequestAccess ? "Request Access" : string.Empty,
                ButtonUri = this.CreateAccessRequestUri(missingAccess)
            };
            this.StateContainer.SetNextNotification(notification);
            NavManager.NavigateTo($"/");
        }
        catch (AccessTokenNotAvailableException exception)
        {
            exception.Redirect();
        }
        finally
        {
            this.IsInProgress = false;
        }
    }

    private async Task DeleteSecretAsync()
    {
        this.IsInProgress = true;

        try
        {
            var secretData = await apiClient.DeleteSecretDataAsync(this.inputModel.Name);

            if (!"ok".Equals(secretData.Status))
            {
                this.Notification = new NotificationData()
                {
                    Type = NotificationType.Warning,
                    Status = secretData.Status,
                    Message = secretData.Error
                };
                return;
            }

            var notification = new NotificationData()
            {
                Type = NotificationType.Success,
                Status = "Success",
                Message = $"Secret '{this.inputModel.Name}' deleted successfully"
            };
            this.StateContainer.SetNextNotification(notification);
            NavManager.NavigateTo($"/");
        }
        catch (AccessTokenNotAvailableException exception)
        {
            exception.Redirect();
        }
        finally
        {
            this.IsInProgress = false;
        }
    }

    public void DismissNotification()
    {
        this.Notification = null;
    }

    private string CreateAccessRequestUri(string permissions)
    {
        return $"addrequest?subject={this.ObjectName}&permission={permissions}";
    }

    private string GetViewUri(string objectName)
    {
        return $"{NavManager.BaseUri.TrimEnd('/')}/viewdata/{objectName}";
    }
}
