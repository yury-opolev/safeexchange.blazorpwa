@using Microsoft.Extensions.Configuration
@using Microsoft.Extensions.Options
@using SafeExchange.Client.Common
@using Microsoft.AspNetCore.Components.WebAssembly.Authentication
@using System.Text.RegularExpressions;
@using System.Text
@using SafeExchange.Client.Common.Model
@using SafeExchange.Client.Web.Components.Model
@using System.IO
@using System.Threading

@implements IDisposable

@inject NavigationManager NavManager
@inject ApiClient apiClient
@inject StateContainer StateContainer
@inject TooltipsInitializer TooltipsInitializerInstance
@inject DownloadUploadHelper downloadUploadHelper
@inject IOptionsSnapshot<RemoteAuthenticationOptions<ApiAuthorizationProviderOptions>> OptionsSnapshot
@inject IConfiguration Configuration

<ItemSearchDialog TItem="GraphUserOutput" @ref="this.userPickDialog" DialogTitle="Find user" Placeholder="Search users..." OnItemPickedCallback="this.FinishUserPick" SearchItemsAsyncCallback="this.SearchUsersAsync" OnClosedCallback="() => this.StateHasChanged()">
    <ItemTemplate Context="user">
        <div class="px-2">
            <div class="text-truncate">
                @user.DisplayName
            </div>
            <div class="text-secondary text-truncate">
                @user.UserPrincipalName
            </div>
        </div>
    </ItemTemplate>
</ItemSearchDialog>

<div class="modal fade" id="deletionDialog" tabindex="-1" role="dialog" aria-labelledby="modalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <p class="modal-title" id="modalLabel"><strong>Delete secret</strong></p>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                Are you sure you want to delete the secret?
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-danger" data-bs-dismiss="modal" @onclick="DeleteSecretAsync">Yes</button>
            </div>
        </div>
    </div>
</div>

@if (this.Notification != null)
{
    <div class="alert alert-dismissible @(this.Notification.GetAlertClass() ?? "alert-primary")" role="alert">
        <p>
            <strong>@(this.Notification.Status ?? string.Empty)</strong>&nbsp; @(this.Notification.Message ?? string.Empty)
        </p>
        @if (!string.IsNullOrEmpty(this.Notification.ButtonText))
        {
            <hr>
            <p>
                <button class="btn btn-warning" type="button" disabled="@this.StateContainer.IsInProgress" @onclick="() => this.HandleNotificationButtonClick()">
                    <span>@this.Notification.ButtonText</span>
                </button>
            </p>
        }
        <button type="button" class="btn-close" @onclick="DismissNotification" aria-label="Close"></button>
    </div>

}

@if (this.compoundModel != null)
{
<EditForm EditContext="@editContext" OnSubmit="@OnSubmitAsync">
    <CompoundModelValidator />

    <p>
        <div class="@(this.editContext.FieldCssClass(() => this.compoundModel.MainData))">
            <div id="quill-toolbar">
              <select class="ql-font">
                <option selected></option>
                <option value="serif"></option>
                <option value="monospace"></option>
              </select>
              <select class="ql-size">
                <option value="small"></option>
                <option selected></option>
                <option value="large"></option>
                <option value="huge"></option>
              </select>
              <span class="ql-formats">
                <button class="ql-bold"></button>
                <button class="ql-italic"></button>
                <button class="ql-underline"></button>
                <button class="ql-strike"></button>
              </span>
              <span class="ql-formats">
                <select class="ql-align"></select>
              </span>
              <span class="ql-formats">
                <select class="ql-color"></select>
                <select class="ql-background"></select>
              </span>
              <span class="ql-formats">
                <button class="ql-link"></button>
                <button class="ql-image"></button>
              </span>
              <span class="ql-formats">
                <button type="button" class="ql-password"><i class="oi oi-lock-locked toolbar-password-img"></i></button>
              </span>
              <span class="ql-formats">
                <button class="ql-clean"></button>
              </span>
            </div>
            <QuillEditor @ref="this.quillEditor" disabled="@this.StateContainer.IsInProgress" aria-label="Content" aria-describedby="content-validation" @bind-Value="this.compoundModel.MainData" Placeholder="Content" OnBlur="@this.HandleEditorLostFocus" OnCopyableElementInserted="@this.HandleCopyableElementInserted" NextElementRef="@this.attachmentsButtonElement" ></QuillEditor>
        </div>
        <ValidationMessage id="name-validation" For="@(() => this.compoundModel.MainData)" />
    </p>

    <p>
    <div class="collapsible-content">
        <button @ref="this.attachmentsButtonElement" class="btn mb-2 d-inline-flex align-items-center" type="button" data-bs-toggle="collapse" data-bs-target="#collapseAttachments" aria-expanded="false" aria-controls="collapseAttachments">
            &nbsp; Attachments
        </button>
        <div class="collapse" id="collapseAttachments">
            <div class="card card-body">

                
                @if ((this.ExistingAttachments?.Count ?? 0) > 0)
                {
                    <ul class="list-group list-group-flush">
                        @for (int ai = 0; ai < this.ExistingAttachments.Count; ai++)
                        {
                            var attachment = this.ExistingAttachments[ai];
                            <li class="list-group-item d-flex justify-content-between align-items-center flex-wrap attachment-row">
                                <div>
                                    <span id="@($"existing-attachment-{ai}")" class="@(this.IsAttachmentDeleted(attachment)? "form-control text-removed" : "form-control bg-light")" >
                                        @attachment.FileName
                                        <small class="text-secondary my-0">&nbsp;&nbsp; Size: @attachment.GetLengthDescription()</small>
                                    </span>
                                </div>
                                <div class="btn-group px-4 attachment-row-last" role="group" aria-label="Attachment button">
                                @if (this.IsAttachmentDeleted(attachment))
                                {
                                    <button id="@($"undelete-existing-attachment-{ai}")" class="btn btn-outline-secondary" type="button" disabled="@this.StateContainer.IsInProgress" @onclick="@(e => this.UndeleteExistingAttachment(attachment))" aria-label="Undo remove attachment" aria-labelledby="@($"undelete-existing-attachment-{ai} existing-attachment-{ai}")"><span class="oi oi-action-undo"></span></button>
                                }
                                else
                                {
                                    <button id="@($"delete-existing-attachment-{ai}")" class="btn btn-outline-danger" type="button" disabled="@this.StateContainer.IsInProgress" @onclick="@(e => this.DeleteExistingAttachment(attachment))" aria-label="Remove attachment" aria-labelledby="@($"delete-existing-attachment-{ai} existing-attachment-{ai}")"><span class="oi oi-x"></span></button>
                                }
                                </div>
                            </li>
                        }
                    </ul>
                }

                @if ((this.Attachments?.Count ?? 0) > 0)
                {
                    <ul class="list-group list-group-flush">
                        @for (int i = 0; i < this.Attachments.Count; i++)
                        {
                            var attachmentIndex = i;
                            var attachment = this.Attachments[i];
                            <li class="attachment-row list-group-item d-flex justify-content-start align-items-center flex-wrap">
                                <div class="px-2">
                                    @switch (attachment.Status)
                                    {
                                        case (UploadStatus.NotStarted):
                                            <i class="oi oi-file text-secondary"></i>
                                            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
                                            break;

                                        case (UploadStatus.InProgress):
                                            <span class="spinner-border spinner-border-sm" role="status"></span>
                                            <span>@($"{attachment.ProgressPercents:00}")%&nbsp;</span>
                                            break;

                                        case (UploadStatus.Success):
                                            <i class="oi oi-check text-success"></i>
                                            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
                                            break;

                                        case (UploadStatus.Error):
                                            <i class="oi oi-warning text-warning"></i>
                                            <span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
                                            break;
                                    }
                                </div>
                                <div>
                                    <span id="@($"attachment-{i}")">@attachment.SourceFile.Name</span>
                                    <small class="text-secondary my-0">&nbsp;&nbsp; Size: @(ContentMetadata.BytesToString(attachment.SourceFile.Size))</small>
                                </div>
                                <div class="btn-group px-4 attachment-row-last" role="group" aria-label="Attachment button">
                                    <button id="@($"remove-attachment-{i}")" class="btn btn-outline-danger" type="button" disabled="@this.StateContainer.IsInProgress" @onclick="@(e => this.Attachments.Remove(attachment))" aria-label="Remove attachment" aria-labelledby="@($"remove-attachment-{i} attachment-{i}")"><i class="oi oi-x"></i></button>
                                </div>
                            </li>
                        }
                    </ul>                        
                }

                <div class="mt-3" >
                    <button id="attachButton" class="btn btn-outline-primary" type="button" disabled="@this.StateContainer.IsInProgress" @onclick="@(async () => await this.ClickFileInputAsync())">Attach file(s)</button>
                    <InputFile id="attachedFileList1" @ref="this.inputFile" style="display:none" OnChange="@this.AddFiles" multiple disabled="@this.StateContainer.IsInProgress" />
                </div>

            </div>
        </div>
    </div>
    </p>

    <p>
    <div class="row align-items-center">
        <div class="col-sm-4">
            <div class="form-check form-switch">
                <InputCheckbox class="form-check-input" type="checkbox" id="scheduleDestroySwitch" disabled="@this.StateContainer.IsInProgress" @bind-Value="this.compoundModel.Metadata.ExpirationMetadata.ScheduleExpiration" />
                <label class="form-check-label" for="scheduleDestroySwitch">Schedule Expiration</label>
            </div>
        </div>
        <div class="col-sm">
            <label for="destroy-datetime-input" class="visually-hidden">Expire At:</label>
            <div class="input-group">
                <div class="input-group-text">Expire At</div>
                <InputDate id="destroy-datetime-input" class="form-control" disabled="@this.StateContainer.IsInProgress" @bind-Value="this.compoundModel.Metadata.ExpirationMetadata.ExpireAt" Type=InputDateType.DateTimeLocal DisplayName="ExpireAt" />
            </div>
        </div>
    </div>
    </p>

    <p>
    <div class="row align-items-center">
        <div class="col-sm-4">
            <div class="form-check form-switch">
                <InputCheckbox class="form-check-input" type="checkbox" id="destroyOnIdleSwitch" disabled="@this.StateContainer.IsInProgress" @bind-Value="this.compoundModel.Metadata.ExpirationMetadata.ExpireOnIdleTime" />
                <label class="form-check-label" for="destroyOnIdleSwitch">Expire after idle time</label>
            </div>
        </div>
        <div class="col-sm">
            <label for="idle-days-input" class="visually-hidden">Idle days:</label>
            <div class="input-group">
                <div class="input-group-text">Idle Days</div>
                <InputNumber id="idle-days-input" class="form-control" disabled="@this.StateContainer.IsInProgress" @bind-Value="this.compoundModel.Metadata.ExpirationMetadata.DaysToExpire" DisplayName="DaysToExpire" />
            </div>
            <ValidationMessage id="idle-days-validation" For="@(() => this.compoundModel.Metadata.ExpirationMetadata.DaysToExpire)" />
        </div>
        <div class="col-sm">
            <label for="idle-timespan-input" class="visually-hidden">Idle time:</label>
            <div class="input-group">
                <div class="input-group-text">Idle Time</div>
                <InputDate id="idle-timespan-input" class="form-control" disabled="@this.StateContainer.IsInProgress" @bind-Value="this.compoundModel.Metadata.ExpirationMetadata.TimeToExpire" Type=InputDateType.Time DisplayName="TimeToExpire" />
            </div>
        </div>
    </div>
    </p>

    <p>
        <strong>Access list:</strong>
    </p>

    @for (int i = 0; i < this.compoundModel.Permissions.Count; i++)
    {
        var tempIndex = i;
        <p>
            <div class="row align-items-center">
                <div class="col-2">
                    <div class="form-floating">
                        <InputSelect id="@($"usertype-input-{i}")" class="@(this.IsDeleted(tempIndex)? "form-control text-removed" : "form-control bg-light")" disabled="@(tempIndex < this.FixedAccessItemCount || this.StateContainer.IsInProgress)"
                            ValueExpression="@(() => compoundModel.Permissions[tempIndex].SubjectType)"
                            Value="@compoundModel.Permissions[tempIndex].SubjectType"
                            ValueChanged="@((SubjectType value) => OnPermissionTypeChanged(compoundModel.Permissions[tempIndex], value))"
                            placeholder="Type" aria-describedby="@($"ut-validation-{i}")">
                            @foreach (var value in Enum.GetValues(typeof(SubjectType)))
                            {
                                <option>@value</option>
                            }
                        </InputSelect>
                        <label for="@($"usertype-input-{i}")" class="form-label">Type</label>
                    </div>
                    <ValidationMessage id="@($"ut-validation-{i}")" For="@(() => compoundModel.Permissions[tempIndex].SubjectType)" />
                </div>
                @switch (compoundModel.Permissions[tempIndex].SubjectType)
                {
                    case (SubjectType.User):
                        <div class="col">
                            <div class="input-group">
                                <div class="form-floating">
                                    <InputText id="@($"username-input-{i}")" class="@(this.IsDeleted(tempIndex)? "form-control text-removed" : "form-control bg-light")" disabled="@this.StateContainer.IsInProgress" @bind-Value="this.compoundModel.Permissions[tempIndex].SubjectName" placeholder="Username" readonly="@(tempIndex < this.FixedAccessItemCount)" aria-describedby="@($"un-validation-{i}")" />
                                    <label for="@($"username-input-{i}")" class="form-label">Username</label>
                                </div>
                                <span class="narrow-floating-group input-group-text">
                                    @if (tempIndex < this.FixedAccessItemCount)
                                    {
                                        <button class="btn btn-link" type="button" disabled aria-label="Find user">
                                            <span class="oi oi-magnifying-glass"></span>
                                        </button>
                                    }
                                    else
                                    {
                                        <button class="btn" type="button" disabled="@(this.StateContainer.IsInProgress)" @onclick="@(e => this.StartUserPickAsync(tempIndex))" aria-label="Find user">
                                            <span class="oi oi-magnifying-glass"></span>
                                        </button>
                                    }
                                </span>
                            </div>
                            <ValidationMessage id="@($"un-validation-{i}")" For="@(() => compoundModel.Permissions[tempIndex].SubjectName)" />
                        </div>
                        break;

                    case (SubjectType.Group):
                        <div class="col">
                            <div class="form-floating">
                                <InputSelect id="@($"group-input-{i}")" class="form-control" disabled="@this.StateContainer.IsInProgress" @bind-Value="compoundModel.Permissions[tempIndex].SubjectName" placeholder="Group" aria-describedby="@($"grp-validation-{i}")">
                                    @if (!this.StateContainer.IsFetchingGroups)
                                    {
                                        if ((this.StateContainer.RegisteredGroups?.Count ?? 0) > 0)
                                        {
                                            foreach (var group in this.StateContainer.RegisteredGroups)
                                            {
                                                <option value="@group.GroupMail">@group.DisplayName</option>
                                            }
                                        }
                                        else
                                        {
                                            <option value="">- No Groups -</option>
                                        }
                                    }
                                </InputSelect>
                                <label for="@($"group-input-{i}")" class="form-label">
                                    @if (this.StateContainer.IsFetchingGroups)
                                    {
                                        <span class="spinner-border spinner-border-sm" role="status"></span>
                                    }
                                    Group
                                </label>
                            </div>
                            <ValidationMessage id="@($"grp-validation-{i}")" For="@(() => compoundModel.Permissions[tempIndex].SubjectName)" />
                        </div>
                        break;

                    case (SubjectType.Application):
                        <div class="col">
                            <div class="form-floating">
                                <InputSelect id="@($"application-input-{i}")" class="@(this.IsDeleted(tempIndex)? "form-control text-removed" : "form-control bg-light")" disabled="@(tempIndex < this.FixedAccessItemCount || this.StateContainer.IsInProgress)" @bind-Value="compoundModel.Permissions[tempIndex].SubjectName" placeholder="Application" aria-describedby="@($"app-validation-{i}")">
                                @if (!this.StateContainer.IsFetchingApplications)
                                {
                                    if ((this.StateContainer.RegisteredApplications?.Count ?? 0) > 0)
                                    {
                                        foreach (var application in this.StateContainer.RegisteredApplications.Where(a => a.Enabled))
                                        {
                                            <option value="@application.DisplayName">@application.DisplayName</option>
                                        }
                                    }
                                    else
                                    {
                                        <option value="">- No Applications -</option>
                                    }
                                }
                                </InputSelect>
                                <label for="@($"application-input-{i}")" class="form-label">
                                    @if (this.StateContainer.IsFetchingApplications)
                                    {
                                        <span class="spinner-border spinner-border-sm" role="status"></span>
                                    }
                                    Application
                                </label>
                            </div>
                            <ValidationMessage id="@($"app-validation-{i}")" For="@(() => compoundModel.Permissions[tempIndex].SubjectName)" />
                        </div>
                        break;
                }
                <div class="col">
                    @if (tempIndex < this.FixedAccessItemCount)
                    {
                        <div class="form-floating">
                            <InputText id="@($"permissions-select-{i}")" class="@(this.IsDeleted(tempIndex)? "form-control text-removed" : "form-control bg-light")" disabled="@this.StateContainer.IsInProgress" @bind-Value="@this.compoundModel.Permissions[tempIndex].PermissionsString" readonly aria-labelledby="@($"permissions-select-{i} username-input-{i}")" />
                            <label for="@($"permissions-select-{i}")" class="form-label">Permissions</label>
                        </div>
                    }
                    else
                    {
                        <div class="form-floating">
                            <InputSelect id="@($"permissions-select-{i}")" class="form-control bg-light" disabled="@this.StateContainer.IsInProgress" @bind-Value="@this.compoundModel.Permissions[tempIndex].PermissionsString" aria-labelledby="@($"permissions-select-{i} username-input-{i}")">
                                <option>Read</option>
                                <option>Read,Write</option>
                                <option>Read,Write,GrantAccess</option>
                                <option>Read,Write,GrantAccess,RevokeAccess</option>
                            </InputSelect>
                            <label for="@($"permissions-select-{i}")" class="form-label">Permissions</label>
                        </div>
                    }
                </div>
                <div class="col-2">
                    @if (this.IsDeleted(tempIndex))
                    {
                        <button id="@($"undo-revoke-button-{i}")" class="btn btn-outline-secondary" type="button" disabled="@this.StateContainer.IsInProgress" @onclick="@(e => this.RemovePermissionItem(tempIndex))" aria-label="Undo revoke access" aria-labelledby="@($"undo-revoke-button-{i} username-input-{i}")"><span class="oi oi-action-undo"></span></button>
                    }
                    else
                    {
                        <button id="@($"revoke-button-{i}")" class="btn btn-outline-danger" type="button" disabled="@this.StateContainer.IsInProgress" @onclick="@(e => this.RemovePermissionItem(tempIndex))" aria-label="Revoke access" aria-labelledby="@($"revoke-button-{i} username-input-{i}")"><span class="oi oi-x"></span></button>
                    }
                </div>
            </div>
        </p>
    }
    <p>
        <div class="row">
            <div class="col">
                <button class="btn btn-outline-primary" type="button" disabled="@this.StateContainer.IsInProgress" @onclick="AddPermissionItem"><span class="oi oi-plus"></span>&nbsp; Add user</button>
            </div>
        </div>
    </p>

    <p>
        <div class="d-flex justify-content-center">
            <button type="submit" class="btn btn-primary mx-2" disabled="@this.StateContainer.IsInProgress">
                @if (this.StateContainer.IsInProgress)
                {
                    <span class="spinner-border spinner-border-sm" role="status"></span>
                }
                else
                {
                    <i class="oi oi-cloud-upload"></i>  
                }
                <span>&nbsp;Update</span>
            </button>
            <button type="button" class="btn btn-danger mx-2" data-bs-toggle="modal" data-bs-target="#deletionDialog" disabled="@this.StateContainer.IsInProgress">
                @if (this.StateContainer.IsInProgress)
                {
                    <span class="spinner-border spinner-border-sm" role="status"></span>
                }
                else
                {
                    <i class="oi oi-x"></i>
                }
                <span>&nbsp;Delete</span>
            </button>
        </div>
    </p>
</EditForm>
}

@code {

    public const int MaxAttachments = 5;

    [Parameter]
    public string ObjectName { get; set; }

    private QuillEditor quillEditor;

    private ElementReference attachmentsButtonElement;

    private List<ContentMetadata> ExistingAttachments { get; set; } = new();

    private List<ContentMetadata> DeletedAttachments { get; set; } = new();

    private List<AttachmentModel> Attachments { get; set; } = new();

    private NotificationData Notification;

    private EditContext editContext;

    private ItemSearchDialog<GraphUserOutput> userPickDialog;

    private int currentPermissionItemIndex;

    private bool initializeTooltips = false;

    private CompoundModel compoundModel = new CompoundModel()
    {
        Metadata = new ObjectMetadata()
        {
            ObjectName = string.Empty,
            Content = new List<ContentMetadata>(),
            ExpirationMetadata = new ExpirationMetadata()
            {
                ScheduleExpiration = false,
                ExpireAt = DateTime.MinValue,
                ExpireOnIdleTime = false,
                IdleTimeToExpire = TimeSpan.Zero
            }
        },
        Permissions = new List<SubjectPermissions>()
        {
            new SubjectPermissions()
            {
                ObjectName = string.Empty,
                SubjectName = string.Empty,

                CanRead = true,
                CanWrite = false,
                CanGrantAccess = false,
                CanRevokeAccess = false
            }
        },
        MainData = string.Empty
    };

    private ObjectMetadata originalMetadata;

    private int FixedAccessItemCount = 0;

    private List<int> DeletedAccessItems = new List<int>();

    private InputFile inputFile;

    public void Dispose()
    {
        //...
    }

    protected override async Task OnInitializedAsync()
    {
        this.StateContainer.IsInProgress = false;
        this.StateContainer.TakeNotification();

        this.ObjectName = this.ObjectName ?? string.Empty;
        this.StateContainer.SetCurrentPageHeader($"Edit '{this.ObjectName}'");

        this.editContext = new EditContext(this.compoundModel);
        await this.FetchSecretAsync(this.ObjectName);
        await this.StateContainer.TryFetchRegisteredApplications(this.apiClient);
        await this.StateContainer.TryFetchRegisteredGroups(this.apiClient);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!this.initializeTooltips)
        {
            return;
        }

        try
        {
            await TooltipsInitializerInstance.InitializeQuillClipboardTooltipsAsync(this.quillEditor.EditorRef, "Copy to clipboard", "Copied");
        }
        finally
        {
            this.initializeTooltips = false;
        }
    }

    private void OnPermissionTypeChanged(SubjectPermissions permissions, SubjectType value)
    {
        permissions.SubjectType = value;
        permissions.SubjectName = string.Empty;
    }

    private async Task ClickFileInputAsync()
    {
        await this.downloadUploadHelper.InvokeAttachFileAsync(this.inputFile);
    }

    private void AddFiles(InputFileChangeEventArgs e)
    {
        this.Attachments.Clear();
        foreach (var file in e.GetMultipleFiles())
        {
            try
            {
                var fileModel = new InputBrowserFileModel(file);
                this.Attachments.Add(new (fileModel));
                if (this.Attachments.Count >= MaxAttachments)
                {
                    break;
                }
            }
            catch (Exception exception)
            {
                Console.WriteLine($"{exception.GetType()}: {exception.Message}");
            }
        }
    }

    private async Task HandleEditorLostFocus()
    {
        if (!this.quillEditor.IsDirty)
        {
            return;
        }

        await this.quillEditor.RefreshContentAsync();
        this.compoundModel.MainData = this.quillEditor.Value;
        this.ValidateContent();
    }

    private void HandleCopyableElementInserted()
    {
        this.initializeTooltips = true;
    }

    private void ValidateContent()
    {
        var fieldIdentifier = this.editContext.Field("MainData");
        this.editContext.NotifyFieldChanged(fieldIdentifier);
    }

    private void AddPermissionItem()
    {
        this.compoundModel.Permissions.Add(new SubjectPermissions()
        {
            ObjectName = string.Empty,
            SubjectName = string.Empty,

            CanRead = true,
            CanWrite = false,
            CanGrantAccess = false,
            CanRevokeAccess = false
        });
    }

    private void RemovePermissionItem(int index)
    {
        if (index >= this.FixedAccessItemCount)
        {
            this.compoundModel.Permissions.RemoveAt(index);
            return;
        }

        if (this.DeletedAccessItems.Contains(index))
        {
            this.DeletedAccessItems.Remove(index);
        }
        else
        {
            this.DeletedAccessItems.Add(index);
        }
    }

    private bool IsDeleted(int index)
    {
        return this.DeletedAccessItems.Contains(index);
    }

    private bool IsAttachmentDeleted(ContentMetadata attachment)
    {
        return this.DeletedAttachments.Contains(attachment);
    }

    private void DeleteExistingAttachment(ContentMetadata attachment)
    {
        this.DeletedAttachments.Add(attachment);
    }

    private void UndeleteExistingAttachment(ContentMetadata attachment)
    {
        this.DeletedAttachments.Remove(attachment);
    }

    private async Task FetchSecretAsync(string objectName)
    {
        this.StateContainer.IsInProgress = true;
        if (this.quillEditor != null)
        {
            await this.quillEditor.SetEnabledAsync(false);
        }
        try
        {
            var compoundModelResult = await this.apiClient.GetCompoundModelAsync(objectName);
            if (!"ok".Equals(compoundModelResult.Status))
            {
                var consentRequired = false;
                var message = compoundModelResult.Error ?? string.Empty;
                var buttonText = "forbidden".Equals(compoundModelResult.Status) ? "Request Access" : string.Empty;
                if ("consent_required".Equals(compoundModelResult.SubStatus))
                {
                    consentRequired = true;
                    message = "User must give consent in AAD to fetch groups in order to use groups authorization.";
                    buttonText = "Consent";
                }

                this.Notification = new NotificationData()
                {
                    Type = NotificationType.Warning,
                    Status = compoundModelResult.Status,
                    Message = message,
                    ButtonText = buttonText,
                    ButtonUri = this.CreateAccessRequestUri("Read"),
                    ConsentRequired = consentRequired
                };

                return;
            }

            this.DismissNotification();

            this.originalMetadata = new ObjectMetadata(compoundModelResult.Result.Metadata);
            this.FixedAccessItemCount = compoundModelResult.Result.Permissions.Count;
            this.ExistingAttachments = new(compoundModelResult.Result.Metadata.Content.Where(c => !c.IsMain));

            this.compoundModel.Metadata = compoundModelResult.Result.Metadata;

            // TODO: would need to have custom control for expiration time to handle seconds. Until then just dropping seconds here.
            var expireAt = this.compoundModel.Metadata.ExpirationMetadata.ExpireAt;
            expireAt = new DateTime(expireAt.Year, expireAt.Month, expireAt.Day, expireAt.Hour, expireAt.Minute, 0, expireAt.Kind);
            this.compoundModel.Metadata.ExpirationMetadata.ExpireAt = expireAt.ToLocalTime();

            this.compoundModel.Permissions = compoundModelResult.Result.Permissions;
            this.compoundModel.MainData = compoundModelResult.Result.MainData;

            await this.quillEditor.SetTextAsync(string.Empty);
            await this.quillEditor.SetHtmlAsync(this.compoundModel.MainData);

            this.initializeTooltips = true;
        }
        catch (AccessTokenNotAvailableException exception)
        {
            exception.Redirect();
        }
        finally
        {
            this.StateContainer.IsInProgress = false;
            if (this.quillEditor != null)
            {
                await this.quillEditor.SetEnabledAsync(true);
            }
        }
    }

    private async Task OnSubmitAsync(EditContext editContext)
    {
        if (this.quillEditor.IsDirty)
        {
            await this.quillEditor.RefreshContentAsync();
            this.compoundModel.MainData = this.quillEditor.Value;
        }

        if (!editContext.Validate())
        {
            return;
        }

        await TryUpdateSecretAsync();
    }

    private async Task TryUpdateSecretAsync()
    {
        this.StateContainer.IsInProgress = true;
        if (this.quillEditor != null)
        {
            await this.quillEditor.SetEnabledAsync(false);
        }
        this.StateHasChanged();
        try
        {
            this.SpecifyExpirationDateTimeKind();
            await using var timer = new Timer(_ => InvokeAsync(() => StateHasChanged()), null, TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1));
            if (!this.compoundModel.Metadata.ExpirationMetadata.Equals(this.originalMetadata.ExpirationMetadata))
            {
                var updatedMetadata = await this.apiClient.UpdateSecretMetadataAsync(
                    this.compoundModel.Metadata.ObjectName,
                    this.compoundModel.Metadata.ToUpdateDto());

                if (!"ok".Equals(updatedMetadata.Status))
                {
                    this.Notification = CreateNotificationData(updatedMetadata.ToResponseStatus());
                    return;
                }
            }

            var mainContent = this.originalMetadata.Content.First(c => c.IsMain);
            var dropResult = await apiClient.DropContentDataAsync(this.compoundModel.Metadata.ObjectName, mainContent.ContentName);
            if (!"ok".Equals(dropResult.Status))
            {
                this.Notification = CreateNotificationData(dropResult.ToResponseStatus());
                return;
            }

            var newMainContent = this.compoundModel.Metadata.Content.First(c => c.IsMain);
            using (var dataStream = new MemoryStream())
            {
                using (var writer = new StreamWriter(dataStream, leaveOpen: true))
                {
                    await writer.WriteAsync(this.compoundModel.MainData);
                    await writer.FlushAsync();
                }

                dataStream.Position = 0;
                var secretData = await apiClient.PutSecretDataStreamAsync(
                    this.compoundModel.Metadata.ObjectName, newMainContent.ContentName, dataStream);
                if (!"ok".Equals(secretData.Status))
                {
                    this.Notification = CreateNotificationData(secretData.ToResponseStatus());
                    return;
                }
            }

            foreach (var deletedAttachment in this.DeletedAttachments)
            {
                var contentDeletionResult = await apiClient.DeleteContentMetadataAsync(this.compoundModel.Metadata.ObjectName, deletedAttachment.ContentName);
                if (!"ok".Equals(contentDeletionResult.Status))
                {
                    // no-op
                }
            }

            await this.apiClient.UploadAttachmentsAsync(this.compoundModel.Metadata.ObjectName, this.Attachments);

            var missingAccess = string.Empty;

            var deletedPermissionItems = new List<SubjectPermissions>();
            foreach (var deletedIndex in this.DeletedAccessItems)
            {
                deletedPermissionItems.Add(this.compoundModel.Permissions[deletedIndex]);
            }

            if (deletedPermissionItems.Count > 0)
            {
                var accessReply = await apiClient.RevokeAccessAsync(
                    this.compoundModel.Metadata.ObjectName, deletedPermissionItems.Select(sp => sp.ToDto()).ToList());
                if (!"ok".Equals(accessReply.Status))
                {
                    missingAccess = "Read,Write,GrantAccess,RevokeAccess";
                }
            }

            var addedPermissionItems = new List<SubjectPermissions>();
            for (int index = this.FixedAccessItemCount; index < this.compoundModel.Permissions.Count; index++)
            {
                if (!string.IsNullOrEmpty(this.compoundModel.Permissions[index].SubjectName))
                {
                    addedPermissionItems.Add(this.compoundModel.Permissions[index]);
                }
            }

            if (addedPermissionItems.Count > 0)
            {
                var accessReply = await apiClient.GrantAccessAsync(
                    this.compoundModel.Metadata.ObjectName, addedPermissionItems.Select(sp => sp.ToDto()).ToList());
                if (!"ok".Equals(accessReply.Status))
                {
                    missingAccess = string.IsNullOrEmpty(missingAccess) ? "Read,Write,GrantAccess" : missingAccess;
                }
            }

            var needToRequestAccess = !string.IsNullOrEmpty(missingAccess);
            var notification = new NotificationData()
            {
                Type = needToRequestAccess ? NotificationType.Warning : NotificationType.Success,
                Status = needToRequestAccess ? "Success/Warning" : "Success",
                Message = needToRequestAccess ? $"Secret '{this.compoundModel.Metadata.ObjectName}' updated successfully, but access was not updated." : $"Secret '{this.compoundModel.Metadata.ObjectName}' updated successfully",
                CopyableUri = this.GetViewUri(this.compoundModel.Metadata.ObjectName),
                ButtonText = needToRequestAccess ? "Request Access" : string.Empty,
                ButtonUri = this.CreateAccessRequestUri(missingAccess)
            };

            this.StateContainer.SetNextNotification(notification);
            NavManager.NavigateTo($"/");
        }
        catch (AccessTokenNotAvailableException exception)
        {
            exception.Redirect();
        }
        finally
        {
            this.StateContainer.IsInProgress = false;
            if (this.quillEditor != null)
            {
                await this.quillEditor.SetEnabledAsync(true);
            }
            this.StateHasChanged();
        }
    }

    private async Task DeleteSecretAsync()
    {
        this.StateContainer.IsInProgress = true;
        try
        {
            var secretData = await apiClient.DeleteSecretDataAsync(this.compoundModel.Metadata.ObjectName);

            if (!"ok".Equals(secretData.Status))
            {
                this.Notification = new NotificationData()
                {
                    Type = NotificationType.Warning,
                    Status = secretData.Status,
                    Message = secretData.Error
                };

                return;
            }

            var notification = new NotificationData()
            {
                Type = NotificationType.Success,
                Status = "Success",
                Message = $"Secret '{this.compoundModel.Metadata.ObjectName}' deleted successfully"
            };

            this.StateContainer.SetNextNotification(notification);
            NavManager.NavigateTo($"/");
        }
        catch (AccessTokenNotAvailableException exception)
        {
            exception.Redirect();
        }
        finally
        {
            this.StateContainer.IsInProgress = false;
        }
    }

    private NotificationData CreateNotificationData(ResponseStatus status)
        => new NotificationData()
    {
        Type = NotificationType.Warning,
        Status = status.Status,
        Message = status.Error,
        ButtonText = "forbidden".Equals(status.Status) ? "Request Access" : string.Empty,
        ButtonUri = this.CreateAccessRequestUri("Read,Write")
    };

    public void DismissNotification()
    {
        this.Notification = null;
    }

    private string CreateAccessRequestUri(string permissions)
    {
        return $"addrequest?subject={this.ObjectName}&permission={permissions}";
    }

    private string GetViewUri(string objectName)
    {
        return $"{NavManager.BaseUri.TrimEnd('/')}/viewdata/{objectName}";
    }

    private void SpecifyExpirationDateTimeKind()
    {
        if (this.compoundModel.Metadata.ExpirationMetadata.ExpireAt.Kind == DateTimeKind.Unspecified)
        {
            this.compoundModel.Metadata.ExpirationMetadata.ExpireAt =
                DateTime.SpecifyKind(this.compoundModel.Metadata.ExpirationMetadata.ExpireAt, DateTimeKind.Local);
        }
    }

    private void HandleNotificationButtonClick()
    {
        if (this.Notification.ConsentRequired)
        {
            var scopesToConsent = new List<string>();
            this.Configuration.Bind("AdditionalScopesToConsent", scopesToConsent);
            var requestOptions = new InteractiveRequestOptions
            {
                Interaction = InteractionType.GetToken,
                ReturnUrl = this.NavManager.Uri,
                Scopes = scopesToConsent ?? Array.Empty<string>().ToList()
            };

            requestOptions.TryAddAdditionalParameter("prompt", "consent");
            this.NavManager.NavigateToLogin(OptionsSnapshot.Get(Options.DefaultName).AuthenticationPaths.LogInPath, requestOptions);
            return;
        }

        this.NavManager.NavigateTo(this.Notification.ButtonUri);
    }

    private async Task StartUserPickAsync(int permissionItemIndex)
    {
        this.currentPermissionItemIndex = permissionItemIndex;
        await this.userPickDialog.StartItemSearchAsync();
    }

    private async Task<BaseResponseObject<List<GraphUserOutput>>> SearchUsersAsync(SearchInput searchInput)
        => await this.apiClient.SearchUsersAsync(searchInput);

    public void FinishUserPick(GraphUserOutput pickedUser)
    {
        this.compoundModel.Permissions[this.currentPermissionItemIndex].SubjectName = pickedUser.UserPrincipalName;
    }
}
